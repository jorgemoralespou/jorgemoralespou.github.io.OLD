<!DOCTYPE HTML>
<html lang="en">

<head>
    <meta charset="utf-8">
    <!-- begin SEO -->
    <title>Learn the Origin</title>
    <meta property="og:locale" content="en_US">
    <meta property="og:site_name" content="Learn the Origin">
    <meta property="og:title" content="Learn the Origin">
    <link rel="canonical" href="http://jorgemoral.es/">
    <meta property="og:url" content="http://jorgemoral.es/">
    <meta name="twitter:site" content="@UnPOUcoDe">
    <meta name="twitter:title" content="Learn the Origin">
    <meta name="twitter:description" content="Touching containers, orchestration and application development properly mixed with a little touch of real life experience">
    <meta name="twitter:url" content="http://jorgemoral.es/">
    <meta name="twitter:card" content="summary">
    <script type="application/ld+json">
        {
            "@context": "http://schema.org",
            "@type": "Person",
            "name": "Jorge Morales Pou",
            "url": "http://jorgemoral.es",
            "sameAs": ["https://twitter.com/UnPOUcoDe", "https://www.linkedin.com/in/jorgemoralespou", "https://github.com/jorgemoralespou"]
        }
    </script>
    <!-- end SEO -->
    <link href="http://jorgemoral.es/feed.xml" type="application/atom+xml" rel="alternate" title="Learn the Origin Feed">
    <title>jorgemoral.es ::
        Home
    </title>
    <!--
    <link rel="stylesheet" href="/css/stylesheet.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">
    -->
    <meta name="generator" content="Nanoc 4.8.0">

    <!-- For all browsers -->
    <link rel="stylesheet" href="/css/main.css">
    <meta http-equiv="cleartype" content="on">
    <!-- start custom head snippets -->
    <!-- insert favicons. use http://realfavicongenerator.net/ -->
    <link rel="stylesheet" href="/css/asciidoc-pygments.css">
</head>

<body  class="layout--single">
    <div class="masthead">
        <div class="masthead__inner-wrap">
            <div class="masthead__menu">
                <nav id="site-nav" class="greedy-nav">
                    <button><div class="navicon"></div></button>
                    <ul class="visible-links">
                        <li class="masthead__menu-item masthead__menu-item--lg"><a href="/">Learn the Origin</a></li>
<!-- UNCOMMENT WHEN IMPLEMENTED
                        <li class="masthead__menu-item"><a href="/categories">Categories</a></li>
-->
<!-- UNCOMMENT WHEN IMPLEMENTED
                        <li class="masthead__menu-item"><a href="/tags">Tags</a></li>
-->
                        <li class="masthead__menu-item"><a href="/all-posts">All posts</a></li>
                        <!--
                        <li class="masthead__menu-item"><a href="/year-archive">By year</a></li>
                        -->
<!-- UNCOMMENT WHEN IMPLEMENTED
                        <li class="masthead__menu-item"><a href="/presentations">Presentations</a></li>
-->
<!-- UNCOMMENT WHEN IMPLEMENTED
                        <li class="masthead__menu-item"><a href="/conferences">Conferences</a></li>
-->
                        <li class="masthead__menu-item"><a href="/about">About me</a></li>
                    </ul>
                    <ul class="hidden-links hidden"></ul>
                </nav>
            </div>
        </div>
    </div>

<!--  USE Breadcrumbs Helper

    <nav class="breadcrumbs">
      <ol itemscope itemtype="http://schema.org/BreadcrumbList">
            <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
              <a href="http://jorgemoral.es/" itemprop="item"><span itemprop="name">Home</span></a>
              <meta itemprop="position" content="1" />
            </li>
            <span class="sep">/</span>
            <li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
              <a href="http://jorgemoral.esdevexp" itemprop="item"><span itemprop="name">Devexp</span></a>
              <meta itemprop="position" content="2" />
            </li>
            <span class="sep">/</span>
            <li class="current">Configuring your application, Part 2</li>
      </ol>
    </nav>
-->

    <div id="main" role="main">
        <div class="sidebar sticky">
            <div itemscope itemtype="http://schema.org/Person">
                <div class="author__avatar">
                    <img src="/images/bio-photo.jpg" class="author__avatar" alt="Jorge Morales">
                </div>
                <div class="author__content">
                    <h3 class="author__name">Jorge Morales</h3>
                    <p class="author__bio">OpenShift Field Product Manager and Developer Advocate working for Red Hat.<br/>Drop me a tweet if you want me to blog about a topic</p>
                </div>

                <div class="author__urls-wrapper">
                    <button class="btn btn--inverse">Follow</button>
                    <ul class="author__urls social-icons">
                        <li><i class="fa fa-fw fa-map-marker" aria-hidden="true"></i> Madrid, Spain</li>
                        <li><a href="https://twitter.com/UnPOUcoDe"><i class="fa fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
                        <li><a href="https://github.com/jorgemoralespou"><i class="fa fa-fw fa-github-square" aria-hidden="true"></i> GitHub</a></li>
                        <li><a href="https://gitlab.com/jorgemoralespou"><i class="fa fa-fw fa-github-square" aria-hidden="true"></i> GitLab</a></li>
                        <li><a href="https://www.linkedin.com/in/jorgemoralespou"><i class="fa fa-fw fa-linkedin-square" aria-hidden="true"></i> LinkedIn</a></li>
                    </ul>
                </div>
            </div>
        </div>

        
<div class="archive">
    <h1 class="page__title"></h1>
    <p></p>
    <h3 class="archive__subtitle">Recent Posts</h3>
    
       <div class="list__item">
           <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
               <h2 class="archive__item-title" itemprop="headline"><a href="/2017/07/trust-your-certs/">Enhancing the local development experience. Trusting your self-signed certificates</a></h2>
               <p class="page__meta">
                  <i class="fa fa-clock-o" aria-hidden="true"></i> 8 minutes
                  Posted: 17/Jul/2017 by Jorge Morales
               </p>
               <p class="archive__item-excerpt" itemprop="description">One of my biggest interests is how to make local development experience with OpenShift as easy as possible. I’m constantly exploring what needs to be enhanced to our current experience as I develop applications for OpenShift very frequently.</p>
               <!--
               <p class="archive__item-excerpt" itemprop="description">
<p>One of my biggest interests is how to make local development experience with OpenShift as easy as possible. I’m constantly exploring what needs to be enhanced to our current experience as I develop applications for OpenShift very frequently. I work hard to understand developers requirements and eventually provide solutions in the tooling we provide. I use to incubate ideas in a project my team owns, <a href="https://github.com/openshift-evangelists/oc-cluster-wrapper">oc-cluster-wrapper</a>. I work very close with our engineering teams to solve these use cases in “oc cluster” or “minishift” depending on the nature of the problem, as even if they both can stand up an OpenShift all-in-one instance for local development, they both have different goals.</p>

<p>Minishift/CDK is the tool that has been created for the end user (a.k.a developer) of OpenShift, where we are trying to streamline and simplify many of the common tasks a developer will do on the platform. It’s an extensible tool, that has recently introduced the notion of “<a href="https://docs.openshift.org/latest/minishift/using/addons.html">addons</a>” to allow users and organizations to provide common bootstrapping to their clusters. (I will talk about this in another post).</p>

<p>In this post I want to focus on something that really annoys me, as a developer, and I will show the solution I have found for this problem. As always, if the community sees that this is convenient for the general user, the developer, we will make sure that minishift implements this solution out of the box.</p>

<p>Now, after reading this blog for a minute, you’ll be wondering what’s my problem. Let me describe it.</p>

<h2 id="the-problem">The problem</h2>

<p>I create and destroy <strong>oc cluster</strong>’s on a daily basis, mainly when I want to work on a branch, on a feature, on a demo, I create a new <strong>oc cluster</strong>, and when I have finished working on that task, and I know I will no longer work on it, I destroy it. Every time I do this, and I access the OpenShift web UI, I am prompted to accept a certificate. OpenShift’s web UI is exposed through https, and <strong>oc cluster</strong> uses self signed certificates for this communication.</p>

<p><img src="/posts/images/trusting_your_certs/web_not_secure.png" alt="Web not secure" /></p>

<p>Once the certificate has been accepted, I will not be prompted again. Although the communication is not trusted, I have voluntarily agreed to trust that certificate. 
If I open a different browser, I will be prompted again to “proceed” understanding the risks that using a self signed certificate implies.</p>

<p><img src="/posts/images/trusting_your_certs/web_login.png" alt="Web login insecure" /></p>

<p>Now, the truth is that I’m not accepting any random certificate on the interwebs that who knows who’s managing it. I’m a developer that has created a cluster on my local machine for self use. That means, that at the end of the day what I’m really doing is trusting me, which is something that I usually do.</p>

<p>The second problem comes when I look into how “<strong>oc cluster</strong>” works, and I see that every time I stand up a new all-in-one instance via “<strong>oc cluster up</strong>” I get a new certificate. Even though I may have accepted already a certificate before for a previous instance, I will again be prompted to trust another certificate. </p>

<p>I’m a mostly Java developer and I’m not an expert on certificates, so after digging a little bit on the internet I learnt that a certificate is signed by what is called a <em>Certificate Authority</em>, which is an entity that is “globally trusted” that validates that who is using the certificate can also be trusted. This is know as a chain of trust. </p>

<p>The process of having a CA validating who you are and what you do so you can be trusted is a complex and costly process, that most of the time is not convenient for ephemeral certificates, those that will live for some time, and are somehow meant for development or testing purposes. That is the reason why “<strong>oc cluster</strong>” provides it’s own Certificate Authority (CA) to be able to create all the certificates it will require when creating a cluster. This Certificate Authority is also created with every new “<strong>oc cluster</strong>”.</p>

<h2 id="what-can-i-do-then">What can I do then?</h2>

<p>First and easiest option is to create a CA myself and provide it to “<strong>oc cluster</strong>” so that every certificate that get’s created is signed by this Certificate Authority. I can then add this CA to the CAs I trust in my laptop, so I will never be prompted again to accept a certificate that is signed by it. This is fairly easy to do as OpenShift provides a convenience command that can be used to create a CA:</p>

<pre><code class="language-bash">$ oc adm ca create-signer-cert \
                     --cert "my-ca.crt" \
                     --key "my-ca.key" \
                     --serial "my-ca.serial.txt" \
                     --name="jorge@localhost"
</code></pre>

<p>Then you can just provide this CA to the “<strong>oc cluster up</strong>” command line, and it will be used.</p>

<pre><code>$ oc cluster up --certificate-authority=my-ca.crt
</code></pre>

<p>This is a really easy solution, but it falls short. This was the time when I got enlightened by one of my colleagues about the risks of this option. <em>If I do globally trust this CA in my laptop and somehow this CA gets leaked from my laptop to someone else, he could just use it malicious purposes that I would blindly “trust”</em>. <strong>This is not a good idea</strong>. </p>

<p>This colleague explained to me that what I should be doing is creating just a certificate that I should reuse between all my <strong>oc cluster</strong>’s, and that this certificate is what I should globally trust on my laptop. This wouldn’t generate any security risk at all.</p>

<p>OK, let’s explore this option then.</p>

<p>One of the characteristics of “<strong>oc cluster</strong>” is that in the bootstrapping process, if there’s already configuration for the instance, it will reuse it (unless it’s not compatible). So, the only thing I need to do is, instead of creating a CA I need to create the certificates that the Web UI will use whenever I access it. </p>

<p>It happens that there’s multiple certificates used by an OpenShift instance, and that the CA that will sign these certificates will be different from instance to instance unless reused. So eventually, I need to create the CA and all the certificates, and provide these to every instance I create.</p>

<p>For this purpose, there is again an “<strong>oc</strong>” command:</p>

<pre><code>$ oc adm ca create-master-certs \
                 --cert-dir=./certs \
                 --master=https://127.0.0.1:8443 \
                 --public-master=https://127.0.0.1:8443  \
                 --hostnames=kubernetes,kubernetes.default,kubernetes.default.svc,kubernetes.default.svc.cluster,kubernetes.default.svc.cluster.local,localhost,openshift,openshift.default,openshift.default.svc,openshift.default.svc.cluster,openshift.default.svc.cluster.local,127.0.0.1,172.17.0.1,172.30.0.1,192.168.65.2
</code></pre>

<p>As you can see, this command needs quite some different information. I will indicate the directory where to leave all the certificates, then the API server’s internal and external URLs and a list of hostnames or IPs that the server certificates should be valid for. This last part is the only challenging one, as it requires me to reuse the same IPs and names to be used for the cluster as part of the –public-hostname argument at bootstrapping time.</p>

<p>Now, the only thing I need to do is, everytime I bootstrap a cluster I need to provide to it all these certificates. In order to do that, I place all these certificates on a well known location on my laptop and then we need to instruct <strong>oc cluster</strong>’s bootstrapping process to preserve the configuration and to use this “well known” location for the master’s config files.</p>

<p>The following options will be required whenever I start an oc cluster:</p>

<pre><code>oc cluster ... --host-config-dir=DIR/config --use-existing-config
</code></pre>

<p>Every cluster I bootstrap from this point will use the same certificates, so the only part left is to instruct my local development system (a.k.a my laptop) to trust this certificate for https communication.</p>

<p>As I use mac, I will register my certificate using KeyChain. You can directly double-click on the certificate you want to add. In this case will be <em>master.server.crt</em>, and then trust the certificate. You can see the process in the following animated image. (There’s a similar process for every Operating System).</p>

<p><img src="/posts/images/trusting_your_certs/trusting_your_cert_mac.gif" alt="Trust your cert" /></p>

<p>From this point, you will never be asked about this certificate by your browser, and you can create as many clusters as you want, as long as you share this certificate to all of them.</p>

<h2 id="making-it-simple">Making it simple</h2>

<p>As you have probably seen, making this tip work with “<strong>oc cluster</strong>” is not trivial. For that, my team has been working on a script that simplifies working with “oc cluster” locally really simple. The script is called “<a href="https://github.com/openshift-evangelists/oc-cluster-wrapper">oc-cluster</a>” and works in the same way as the base command “oc cluster” but in a simpler way. </p>

<p>All these boilerplate that I have presented here is already built into that script, and you can just create a cluster by:</p>

<pre><code>oc-cluster up
</code></pre>

<p>The only step left to you is to trust the certificate. If you do it, the burden of being asked for every cluster you create will be removed.</p>

<p>All the convenience this script provides (which is not the topic of this blog), is used as incubation for developer usability requirements that will get introduced into <a href="https://github.com/minishift/minishift">minishift</a>, meaning that eventually minishift will support similar functions.</p>

<h2 id="wrap-up">Wrap up</h2>

<p>Here I have presented a way of making your local development experience easier by avoiding you the naggy behaviour of having to accept the self signed certificate every time you create a cluster with oc cluster. </p>

<p>There are a lot of small improvements one can make to improve their day to day experience, and that is what we are exploring and contributing into minishift. Minishift is the most streamlined way of working locally with openshift clusters for developers and what I recommend all of you to use, although some of the ideas we experiment in “oc-cluster” are not yet implemented, but they will soon be.</p>

<p>But remember, minishift is not a “production ready cluster” or a tool for “operations”. It is just meant to be used as the cluster where developers will test their applications early in the process. This is very important to remember. The experience in minishift is and will further be streamlined for development.</p>
</p>
               -->
           </article>
       </div>
    
       <div class="list__item">
           <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
               <h2 class="archive__item-title" itemprop="headline"><a href="/2017/04/chained-builds/">Enhancing your Builds on OpenShift. Chaining Builds.</a></h2>
               <p class="page__meta">
                  <i class="fa fa-clock-o" aria-hidden="true"></i> 16 minutes
                  Posted: 19/Apr/2017 by Jorge Morales
               </p>
               <p class="archive__item-excerpt" itemprop="description">Chaining builds in OpenShift you can do fancy things like using an alternate builder tool, using an alternate runtime, or making a slim runtime image.</p>
               <!--
               <p class="archive__item-excerpt" itemprop="description"><div class="paragraph">
<p>OpenShift provides different options for building and deploying containers on the platform.  These generally include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Build and deploy from application source code</strong> - Users can specify the location of their source code in a GIT repository.  OpenShift will build the application binaries, then build the container images that include those binaries and deploy to OpenShift. Users can also specify a dockerfile as the source code to build container images from.</p>
</li>
<li>
<p><strong>Build and deploy from application binaries</strong> - Users can also specify the location of their application binaries, coming from their existing application build process and tools.  OpenShift will just build the container images that include those provided binaries and deploy to OpenShift.</p>
</li>
<li>
<p><strong>Build outside of OpenShift</strong> - Users can build their applications and container images completely outside of OpenShift, coming from their existing application and container image build process and tools, and specify the location of those images to pull in. OpenShift will just deploy those container image as provided.</p>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_enhancing_your_builds_on_openshift_chaining_builds">Enhancing your Builds on OpenShift: Chaining Builds.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As previously described, OpenShift provides a mechanism to bring your applications to run in containers on the platform, while abstracting much of the detail of the underlying container runtime, Kubernetes orchestration, and platform itself. This mechanism is called <a href="https://docs.openshift.org/latest/architecture/core_concepts/builds_and_image_streams.html#source-build">s2i (source-to-image)</a> which uses builder images to build your applications in containers. A builder image is a standard Docker/OCI image that contains additional builder scripts which can build your applications from source or binaries. In the case of Java, the builder images use Java build tools like Maven or Gradle to build an artifact type (jar, war, or ear) and will layer that on a java runtime (JDK, Tomcat, JBoss EAP, Wildfly-Swarm,&#8230;&#8203;) and the end result will be packaged as a new container image for your application and deployed as a container.</p>
</div>
<div class="paragraph">
<p>In addition to the typical scenario of using source code as the input to a build, OpenShift build capabilities provides another build input type called “Image source”, that will stream content from one image (source) into another (destination).</p>
</div>
<div class="paragraph">
<p>Using this, we can combine source from one or multiple source images. And we can pass one or multiple files and/or folders from a source image to a destination image. Once the destination image has been built it will be pushed into the registry (or an <a href="https://blog.openshift.com/pushing-application-images-to-an-external-registry/">external registry</a>), and will be ready to be deployed.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/image_source.png" alt="Image Source">
</div>
</div>
<div class="paragraph">
<p>Using an image (or multiple) as the source of the content you want to stream into the destination image may appear unnecessarily complicated, but it opens the door to splitting the build process into two (or even more) different stages: <strong>build</strong> and <strong>assemble</strong>.</p>
</div>
<div class="paragraph">
<p>The <strong>build</strong> stage will use a regular source to image process and will pull down your application source code from Git and build it into an application artifact, publishing a new image that contains the built artifact. That’s the sole goal for this stage. For this reason, we can have specialized images that will know how to build an application artifact (or binary) using building tools, like maven, Gradle, go, …</p>
</div>
<div class="paragraph">
<p>The <strong>assemble</strong> stage will copy the binary artifact from the “source” image built in the previous stage and put it in a well known location that a runtime image will use to look for this artifact. Examples of such images could be Wildfly, JBoss EAP, Tomcat, Java OpenJDK, or even scratch (a special image without a base). In this stage we will just need to indicate where the artifacts are located in the source image and where they need to be copied in the destination image. The build process will create an image that will be pushed into the registry and will be known as the application image.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/chaining.png" alt="Chaining builds">
</div>
</div>
<div class="paragraph">
<p>Now, I’m going to demonstrate this process with three different examples, that will give us the following benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Build the app binaries with a regular s2i builder image and run the app using a vanilla (non s2i) image as the base image.</p>
</li>
<li>
<p>Build the app binaries with a custom s2i builder image with a build tool (like Gradle), and run the app using an officially supported s2i image as the base.</p>
</li>
<li>
<p>Make a minimal runtime image (which has many side benefits).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
At the end of each example there is the complete code snippet that you can use to reproduce the example in your own environment.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_example_1_maven_builder_non_s2i_wildfly_runtime">Example 1: Maven builder + non-s2i Wildfly Runtime</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this example I will use as runtime image a vanilla wildfly image, which will give me a smaller final image size compared to the s2i version of wildfly. I will use <a href="https://hub.docker.com/r/jboss/wildfly/">the community version of wildfly available at Docker Hub</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/1-wildfly-size.png" alt="Wildfly image sizes">
</div>
</div>
<div class="paragraph">
<p>I’ll use <a href="https://github.com/minishift/minishift">minishift</a> to start a local OpenShift cluster on my laptop to run these examples, but any OpenShift environment will work.</p>
</div>
<div class="paragraph">
<p>I’ll start my minishift environment:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/minishift_start.png" alt="minishift start">
</div>
</div>
<div class="paragraph">
<p>Once I have my local environment up and running, I’ll create a new-project to isolate all the changes I do:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/1-newproject.png" alt="New project">
</div>
</div>
<div class="paragraph">
<p>In this example, I’m going to chain two builds. The first build will use any of the available java based s2i builders in OpenShift, as I only want to build my Java artifact using maven. I’ll use the <a href="https://hub.docker.com/r/openshift/wildfly-101-centos7/">s2i-wildfly builder image</a>, and will build a <a href="https://github.com/OpenShiftDemos/os-sample-java-web">sample Java application which I have available in GitHub</a>. Additionally I’ll give this build a name. Let’s keep it simple and call it “<strong>builder</strong>”.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/1-newbuild-builder.png" alt="Builder image build">
</div>
</div>
<div class="paragraph">
<p>Once the build has finished, which you can verify by watching the build log, I’ll create a second build that will copy the generated artifact from the first build into the second. This second build will use jboss/wildfly image as base, and will copy the ROOT.war artifact from the builder image into the appropriate location. This second build will be a docker build and not a source build, like the previous. I’ll give this build a representative name again. This time the name will be “<strong>runtime</strong>”.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/1-newbuild-runtime.png" alt="Runtime image build">
</div>
</div>
<div class="paragraph">
<p>Now I already have my runtime image built, with the application artifact. The only thing missing is to have the application deployed, so I’ll start a new-app from the “runtime” image, and will give it again a meaningful name, “<strong>my-application</strong>”. Then, I’ll create a route and verify that the application is up and running.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/1-new-app.png" alt="New application">
</div>
</div>
<div class="paragraph">
<p>This is a simple example where I’m using a non-s2i image to run my application built in OpenShift. I could have used any Docker image, it doesn’t need to be jboss/wildfly, but I used this one since you already know where I work ;-)</p>
</div>
<div class="paragraph">
<p>You’ll see this application like any other application on the OpenShift Overview.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/1-overview.png" alt="Overview UI">
</div>
</div>
<div class="paragraph">
<p>The main difference is that your application will have two builds, and the application itself, the code, will be built by the “builder” build, in case you want to set a GitHub webhook for your source code.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/1-builds.png" alt="Builds">
</div>
</div>
<div class="paragraph">
<p>If you want to exercise all the code yourself, you only need to copy and paste the following snippet, which is also available in <a href="https://github.com/jorgemoralespou/ose-chained-builds/blob/master/maven-jbosswildfly/example.sh">GitHub</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">oc new-project maven-jbosswildfly
oc new-build wildfly~https://github.com/OpenShiftDemos/os-sample-java-web --name=builder

# watch the logs
oc logs -f bc/builder

# Generated artifact is located in /wildfly/standalone/deployments/ROOT.war
oc new-build --name=runtime --docker-image=jboss/wildfly \
     --source-image=builder \
     --source-image-path=/wildfly/standalone/deployments/ROOT.war:. \
     --dockerfile=$'FROM jboss/wildfly\nCOPY ROOT.war /opt/jboss/wildfly/standalone/deployments/ROOT.war'


oc logs -f bc/runtime

# Deploy and expose the app once built
oc new-app runtime --name=my-application
oc expose svc/my-application

# Print the endpoint URL
echo “Access the service at http://$(oc get route/my-application -o jsonpath='{.status.ingress[0].host}')/”</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let’s now explore a different use case for which chained builds can be helpful.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_example_2_gradle_builder_jdk_runtime">Example 2: Gradle builder + JDK Runtime</h2>
<div class="sectionbody">
<div class="paragraph">
<p>What happens when you want to to run your application with our officially supported OpenJDK image which has been created to run your Java based microservices, but your source code needs to be built using “Gradle”, which is not available in that image?</p>
</div>
<div class="paragraph">
<p>In this example I will leverage a builder image I created with support for Gradle (<a href="https://github.com/jorgemoralespou/s2i-java">jorgemoralespou/s2i-java</a>) for a <a href="https://blog.openshift.com/using-openshift-enterprise-grade-spring-boot-deployments/">previous post</a>, and then, as in the previous example, I will copy the generated artifact into the official openjdk18-openshift image.</p>
</div>
<div class="paragraph">
<p>For brevity I will only paste the snippet that does all, as the process was already explained in the previous example.</p>
</div>
<div class="paragraph">
<p>The only caveat to this process is that you need to know where the built artifact is left in the builder image and where you need to place the artifact in the runtime image.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">oc new-project gradle-jdk
oc new-build jorgemoralespou/s2i-java~https://github.com/jorgemoralespou/s2i-java \
   --context-dir=/test/test-app-gradle/ --name=builder

sleep 1

# watch the logs
oc logs -f bc/builder

# Generated artifact is located in /wildfly/standalone/deployments/ROOT.war
oc new-build --name=runtime \
   --docker-image=registry.access.redhat.com/redhat-openjdk-18/openjdk18-openshift \
   --source-image=builder --source-image-path=/opt/openshift/app.jar:. \
   --dockerfile=$'FROM registry.access.redhat.com/redhat-openjdk-18/openjdk18-openshift\nCOPY app.jar /deployments/app.jar'

sleep 1

oc logs -f bc/runtime

# Deploy and expose the app once built
oc new-app runtime --name=my-application
oc expose svc/my-application

# Print the endpoint URL
echo “Access the service at http://$(oc get route/my-application -o jsonpath='{.status.ingress[0].host}')/”</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have created two different builds, one for building my application and another one for creating the runtime application.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/2-builds.png" alt="Builds">
</div>
</div>
<div class="paragraph">
<p>The deployed application can be seen in the overview page.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/2-overview.png" alt="Overview UI">
</div>
</div>
<div class="paragraph">
<p>Clicking on the route you’ll see the cool example in action.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/2-app.png" alt="Application">
</div>
</div>
<div class="paragraph">
<p>As can be seen, in the process, there are 4 ImageStreams involved:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/2-imagestreams.png" alt="ImageStreams">
</div>
</div>
<div class="paragraph">
<p>The two base images used, s2i-java for building using Gradle, and openjdk18-openshift to be used as base for running our application. Also there is a builder and runtime ImageStream as result of our builds. Our deployment is based on the “runtime” ImageStream.</p>
</div>
<div class="paragraph">
<p>Now that we’ve seen how to use a different builder technology than the available in the images we want to run, let’s explore a final example on how to get a minimal runtime image.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_example_3_s2i_go_builder_scratch_runtime">Example 3: S2I Go builder + Scratch Runtime</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Go is a language where you run a “standalone” binary that can be statically compiled to have all the dependencies it requires. In this way, you can run a minimal image with a go binary that is easy to distribute.</p>
</div>
<div class="paragraph">
<p>As there is no official go-s2i image, I have modified the one available in <a href="https://github.com/openshift-s2i/s2i-go">GitHub</a> to statically build a binary. The source code for this image is available in <a href="https://github.com/jorgemoralespou/s2i-go">GitHub</a> and the image is published in Docker Hub under <a href="https://hub.docker.com/r/jorgemoralespou/s2i-go/">jorgemoralespou/s2i-go</a>. Keep in mind this image has been built just to prove this use case and that given my lack of expertise in go, you shouldn’t trust it (or use it) for anything important.</p>
</div>
<div class="paragraph">
<p>I have an example go application that is a web server showing a <a href="https://github.com/jorgemoralespou/ose-chained-builds/blob/master/go-scratch/hello_world/main.go">hello-world in GitHub</a>, and will be used for this third example.</p>
</div>
<div class="paragraph">
<p>As before, and given that the process is the same, I’ll just paste the code snippet that you can copy and paste in your terminal to verify yourself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">oc new-project go-scratch
oc import-image jorgemoralespou/s2i-go --confirm
oc new-build s2i-go~https://github.com/jorgemoralespou/ose-chained-builds \
   --context-dir=/go-scratch/hello_world --name=builder

sleep 1

# watch the logs
oc logs -f bc/builder

# Generated artifact is located in /opt/app-root/src/go/src/main/main
oc new-build --name=runtime \
   --docker-image=scratch \
   --source-image=builder \
   --source-image-path=/opt/app-root/src/go/src/main/main:. \
   --dockerfile=$'FROM scratch\nCOPY main /main\nEXPOSE 8080\nENTRYPOINT ["/main"]'

sleep 1

oc logs -f bc/runtime

# Deploy and expose the app once built
oc new-app runtime --name=my-application
oc expose svc/my-application

# Print the endpoint URL
echo “Access the service at http://$(oc get route/my-application -o jsonpath='{.status.ingress[0].host}')/”</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the process has finished, we can compare the size of the images. The builder image would be my application image if I wouldn’t have chained into a new build. The runtime image, as it is based off SCRATCH and has just the statically built binary, is 150x smaller in size.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/3-imagesize.png" alt="Image sizes">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_make_it_simple_make_it_repeatable">Make it simple, make it repeatable</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that we have set up 3 different use cases to which chaining builds can provide some benefit, we can abstract all these complexity in a template, so we just need to instantiate a template providing the location of our source code repository and the name of our application.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/chained_builds/3-template.png" alt="Template">
</div>
</div>
<div class="paragraph">
<p>Additionally we can augment this template with any parameterization we might want to make configurable.</p>
</div>
<div class="paragraph">
<p>It is also important to note that using some of the building capabilities provided by OpenShift we have set up an ImageChangeTrigger on the second build so there is no need to manually launch both builds. The second build will be started by OpenShift once the first has finished as a result of the new image being created by the first build.</p>
</div>
<div class="paragraph">
<p>Using a template simplifies your user experience and provides you a mechanism to create this type of applications with a single command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">oc new-app go-scratch \
           -p name=my-application \
           -p GIT_URI= https://github.com/jorgemoralespou/ose-chained-builds \
           -p CONTEXT_DIR=/go-scratch/hello_world</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusions">Conclusions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To conclude this article, I want you to think about all the capabilities that the platform provides and that sometimes are not obvious to us. With this technique, we can do much more fancy things, that I will show in a follow up blog.</p>
</div>
<div class="paragraph">
<p>Also, as many of you would have probably figured out, there’s not only benefits in what I just showed. There will be two docker images being built, pushed and stored in the registry and there will be a bigger maintenance burden. But, the most important thing to understand is that the platform does not limit us in many ways that we could have thought of.</p>
</div>
<div class="paragraph">
<p>As always, the complete content used for this blog is available in <a href="https://github.com/jorgemoralespou/ose-chained-builds">GitHub</a>.</p>
</div>
<div class="paragraph">
<p>I hope that this has given you some food for thought. Happy to chat about it.</p>
</div>
</div>
</div></p>
               -->
           </article>
       </div>
    
       <div class="list__item">
           <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
               <h2 class="archive__item-title" itemprop="headline"><a href="/2017/04/developing-locally-openshift-minishift/">Developing locally with OpenShift - minishift, bringing it all together</a></h2>
               <p class="page__meta">
                  <i class="fa fa-clock-o" aria-hidden="true"></i> 4 minutes
                  Posted: 08/Apr/2017 by Jorge Morales
               </p>
               <p class="archive__item-excerpt" itemprop="description">In this last post I'm introducing what is the definitive tool for working with OpenShift locally and where we'll be investing moving forward.</p>
               <!--
               <p class="archive__item-excerpt" itemprop="description"><div class="paragraph">
<p>We finally get to the last post of the series, and in this post I will introduce you to the tool that Developers will be using soon. It’s still not final and yet many features need to be planned and included, but will overcome all the problems I described in my previous posts.</p>
</div>
<div class="paragraph">
<p>There’s already a good blog post from <a href="https://github.com/LalatenduMohanty">Lalatendu Mohanty</a> about <a href="https://developers.redhat.com/blog/2017/02/28/using-red-hat-container-development-kit-3-beta/">what CDKv3 is</a> so I will not go into many details. I will just simply quote him for what I consider the most important part:</p>
</div>
<div class="paragraph">
<p>“Minishift is a fork of the Minikube project and uses libmachine to interact with the underlying virtualization software. It also uses OpenShift’s “cluster up” functionality for provisioning the local Origin/OCP cluster”</p>
</div>
<div class="paragraph">
<p>Also:</p>
</div>
<div class="paragraph">
<p>“At the moment, KVM, Virtualbox, Xhyve and HyperV are the supported hypervisors.”</p>
</div>
<div class="paragraph">
<p>You should note that from this 2 sentences there is so many relevant things to mention:</p>
</div>
<div class="paragraph">
<p>First, and foremost, the tool runs in a virtual machine, providing isolation from the host. Also, the support for the most common virtualization technologies across all major Operating Systems, providing consistency on where minishift can be run. And finally, minishift uses internally “oc cluster up” which is the preferred way to bootstrap a local cluster.</p>
</div>
<div class="paragraph">
<p>One of the key aspects of minishift is that it is a tool created with developers in mind, so most of the shortcomings that “oc cluster” provides are meant to be overtaken by minishift. But, not only is a tool for developers, it’s also a tool to have reproducible OpenShift local environments. This aspect is key for some alternative use cases, like teaching or showing OpenShift capabilities in a reproducible manner. Evangelism of OpenShift will greatly benefit from the sweetness that minishift provides.</p>
</div>
<div class="paragraph">
<p>As an example of things that are or will be shortly possible:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reuse downloaded images from VM to VM</p>
</li>
<li>
<p>Provision a set of addons/bundles upon cluster creation</p>
</li>
<li>
<p>Modify cluster default behavior</p>
</li>
<li>
<p>Provide multiple openshift instances/profiles</p>
</li>
<li>
<p>Ability to pack and transfer files required to have a working environment</p>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_how_to_get_started">How to get started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To work with minishift is as easy as it is to work with “oc cluster”. It’s a single go binary compiled for the different major developers operating systems (Windows, Mac and Linux). The only pre-requirement is that you have any of the supported virtualization technologies available on your workstation. Once you have the binary downloaded, and for convenience, added to the path, you can just issue one command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ minishift start</pre>
</div>
</div>
<div class="paragraph">
<p>This command, which accepts a variety of configuration flags, does all you need to have OpenShift up and running. It will pull down a boot-2-docker iso (there’s also Centos and RHEL variants), it will create a VM using that iso image, and will do “oc cluster up” within the VM, with the appropriate configuration. After all the images have been pulled down (which can take a while) you’ll have a complete OpenShift all in one cluster running in a VM.</p>
</div>
<div class="paragraph">
<p>Once you finish working, you just need to stop the VM, by doing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ minishift stop</pre>
</div>
</div>
<div class="paragraph">
<p>Note that this will keep the VM in your workstation, so you can start and stop it several times being sure that your work will be preserved.</p>
</div>
<div class="paragraph">
<p>Once you’re done, you can discard the VM and recover all used disc space, by doing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ minishift delete</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusions">Conclusions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although minishift has not even hit version 1.0.0 GA it is already one of the easiest ways to work with Openshift locally. But the truth is that if the present is encouraging the future is promising, and we will see a great deal of capabilities being added moving forward that will keep simplifying developers life, so that a regular developer will not need to know how to install, manage, configure and operate and OpenShift cluster and will be able to keep focus in what should be important to him, develop applications that will ultimately run on an OpenShift cluster.</p>
</div>
<div class="paragraph">
<p>I have to say that these past months where I’ve been working with the minishift team, they have proved that “being the tool of choice for developers” is their main goal, and they have been listening to all the feedback from the community to make the experience as easy as possible. I want to thank <a href="https://github.com/hferentschik">Hardy Ferentschik</a>, <a href="https://github.com/LalatenduMohanty">Lalatendu Mohanty</a>, <a href="https://github.com/praveenkumar">Praveen Kumar</a>, <a href="https://github.com/budhrg">Budh Ram Gurung</a>, <a href="https://github.com/gbraad">Gerard Braad</a>, and the rest of the <a href="https://github.com/minishift/minishift/graphs/contributors">minishift team</a>, and also specially <a href="https://github.com/jimmidyson">Jimmy Dyson</a> who started this project.</p>
</div>
</div>
</div></p>
               -->
           </article>
       </div>
    
       <div class="list__item">
           <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
               <h2 class="archive__item-title" itemprop="headline"><a href="/2017/04/developing-locally-openshift-oc-cluster/">Developing locally with OpenShift - “oc cluster up”, the fastest way to get a local cluster</a></h2>
               <p class="page__meta">
                  <i class="fa fa-clock-o" aria-hidden="true"></i> 10 minutes
                  Posted: 07/Apr/2017 by Jorge Morales
               </p>
               <p class="archive__item-excerpt" itemprop="description">In this 3rd blog in the series, we're exploring what is the fastest way to stand up an OpenShift cluster for development, and I'll introduce you to a tool that I've created for experimentation on additional use cases</p>
               <!--
               <p class="archive__item-excerpt" itemprop="description"><div class="paragraph">
<p>Some time after we launched, we realized how easy it was to run OpenShift itself as a Docker container, as that’s one of the possible ways to install and run OpenShift. Our lead architect, <a href="https://github.com/smarterclayton/">Clayton Coleman</a>, realized that since every developer will probably have the “oc” (OpenShift client) client tool available on their machines, it could be very easy to add some behaviour to that client to bootstrap a local OpenShift instance. This is how he came with the command cluster and the options up and down.</p>
</div>
<div class="paragraph">
<p><strong>“oc cluster up”</strong> will start an openshift all-in-one Docker container on your workstation and it will do some bootstrapping to make it usable. With the command comes many switches so that the behaviour can be customized.</p>
</div>
<div class="paragraph">
<p><strong>“oc cluster down”</strong> will stop that container and remove any configuration used by it.</p>
</div>
<div class="paragraph">
<p>A subsequent start of a cluster, again with “oc cluster up” will bring up a fresh new cluster. This means that the cluster that you have started is not persisted by default, unless one uses the switch “--keep-config” that will preserve the configuration upon restarts.</p>
</div>
<div class="paragraph">
<p>How does “oc cluster” works? It runs an origin (or ocp) Docker container natively and then it does some bootstrapping to provide some initial configuration. Wait? Did I say a Docker container natively? Yes. This means that for Windows and Mac users you’ll need to use either Docker for Windows or Docker for Mac respectively. Docker for Windows and Docker for Mac uses lightweight virtualization (hyper-V and xhyve respectively) and start a Boot-2-Docker VM, that is very small in size (around 35 MB).</p>
</div>
<div class="sect1">
<h2 id="_how_to_get_started">How to get started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Download the oc client from <a href="https://github.com/openshift/origin/releases">origin releases</a> (lookup for the latest stable)</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/developing_locally_openshift/origin_releases.png" alt="Origin releases">
</div>
</div>
<div class="paragraph">
<p>Next, start the cluster:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">oc cluster up</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/developing_locally_openshift/insecure_registry_error.png" alt="Insecure registry error">
</div>
</div>
<div class="paragraph">
<p>You’ll get a warning about the registry. Just add the registry to the list of insecure registries of your Docker installation.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/developing_locally_openshift/add_registry.png" alt="Add registry">
</div>
</div>
<div class="paragraph">
<p>At this point you have a fully functional openshift cluster up and running and available to you. The OpenShift console address is displayed in the output messages, but can also be queried by issuing the following command: at “oc whoami --show-server”. On the startup log there will also be user related information.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/developing_locally_openshift/cluster_started.png" alt="Add registry">
</div>
</div>
<div class="paragraph">
<p>When you’re done working, just do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">oc cluster down</code></pre>
</div>
</div>
<div class="paragraph">
<p>There’s a lot of command line switches to customize the cluster behavior. Starting a cluster for a different origin version or configuring proxies for your cluster are some of the things that can be easily configured.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_evolution">Evolution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>“oc cluster” started as a way for OpenShift engineers to have a cluster up to test their work and soon became the easier way to start a cluster. It was first introduced in 1.3 and it has been adding some features on every release, although just the minimal required features for the intended goal. OpenShift version 1.4/3.4 introduced the ability to bootstrap a proxy and some other behavioral changes. OpenShift 1.5/3.5 will introduce Persistent Volumes, so anytime a cluster is bootstrapped, 100 PV will be created and available for the developer to use.
There is a lot of <a href="https://github.com/openshift/origin/issues?utf8=%E2%9C%93&amp;q=is%3Aissue%20is%3Aopen%20in%3Atitle%20%22oc%20cluster%22%20">work going</a> into the tool.
Although many engineers have contributed to this tool, most of the work has been done by <a href="https://github.com/csrwng/">Cesar Wong</a>. So my most sincere kudos to Cesar for his amazing work.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_is_it_enough">Is it enough?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let’s start by saying that I love “oc cluster” as it gives an easy way to bootstrap a cluster based of a Docker container. This is the fastest way to get a cluster up and running. It only requires you to have the oc client, which if you use OpenShift at all you will already have it. And it’s easy to learn. You just need to remember 2 commands “oc cluster up” and “oc cluster down”.
On the contrary, I have to say that the default behavior does not make developing applications for that local OpenShift environment agile, as you’ll most likely not use the default behavior and will need to always provide command line switches.</p>
</div>
<div class="paragraph">
<p>The goal of this tool is not to provide a local, reusable, development environment, for those that develop applications that will run on OpenShift. It just provides a fast way to have a cluster available. In many cases, this will be sufficient, but not for me, and what I’m looking for as developer of applications for OpenShift.</p>
</div>
<div class="paragraph">
<p>The workflow I look for as a developer of applications for Openshift should look like:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Start an env</p>
</li>
<li>
<p>Work on it</p>
</li>
<li>
<p>Stop an env</p>
</li>
<li>
<p>Start another env</p>
</li>
<li>
<p>Bootstrap it differently for that project</p>
</li>
<li>
<p>Stop that env</p>
</li>
<li>
<p>Start, develop, stop</p>
</li>
<li>
<p>Destroy a no longer needed env.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This has been the main motivation for me to start a side project, a bash script that wraps “oc cluster” and gives me the workflow I’m looking for. The script is named “oc-cluster” and is <a href="https://github.com/openshift-evangelists/oc-cluster-wrapper">available on GitHub</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__oc_cluster_wrapper_gaining_experience_with_developers">“oc-cluster” wrapper: Gaining experience with developers.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the process of creating this tool I have done many experimentation on what would be the common bootstrapping that I would require so I have provided a mechanism to configure anything else that I don’t consider basic in an easy way than what is provided out of the box. There is a plugin mechanism that allows all these add ons to be installed on demand and they can be easily shared between different people.</p>
</div>
<div class="paragraph">
<p>The mechanics are the same as the base “oc cluster”, but it provides a default additional parameter which is the name of the cluster to start. This allows the developer to have multiple clusters created and start/stop the one with the work/add ons they want.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">oc-cluster up [PROFILE]</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/developing_locally_openshift/oc-cluster_up.png" alt="oc-cluster up">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">oc-cluster stop</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/developing_locally_openshift/oc-cluster_down.png" alt="oc-cluster down">
</div>
</div>
<div class="paragraph">
<p>This is all you need to know, but as I have introduced the concept of profiles, you can then list the available clusters to decide which one you want to start in case you don’t remember the name.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/developing_locally_openshift/oc-cluster_list.png" alt="oc-cluster list">
</div>
</div>
<div class="paragraph">
<p>Also, as the clusters are now long lived, you will be able to completely delete the cluster if you’re not going to work with it any more.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="/posts/images/developing_locally_openshift/oc-cluster_destroy.png" alt="oc-cluster destroy">
</div>
</div>
<div class="paragraph">
<p>The tool has a lot of features targeting make developing on openshift easy, so if you want more information in how this tool works and all the capabilities it has, I recommend you to read the <a href="https://github.com/openshift-evangelists/oc-cluster-wrapper/blob/master/README.adoc">README.adoc in GitHub</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusions">Conclusions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>“oc cluster” it’s an awesome tool to get a cluster up and running, but it really don’t fulfill all my expectations for using it as my local development environment for a day to day development tool. That is the reason has has driven me to create a tool on top.</p>
</div>
<div class="paragraph">
<p>The biggest advantage of this tool that created on top is that it totally adjusts to my workflow and expectations, as it is developed by me ;-), and it’s developed in my free time. Windows is not supported as bash does not run there natively.
There’s an alternative to this script, written by <a href="https://github.com/GrahamDumpleton">Graham Dumpleton</a>, written in Python, which supports Windows as well as MacOS X and Linux, called <a href="https://github.com/getwarped/powershift-cluster">Powershift</a>.</p>
</div>
<div class="paragraph">
<p>This side project has been mainly developed to make my daily life easier, but by sharing it, I’ve been collecting a big understanding on what users would expect when working with OpenShift locally, either for development or for any other purpose, like demos or even evangelism.
All this feedback is being constantly shared with the people working on “oc cluster” and “minishift”, to make continuously improve these tools, as these are officially provided by Red Hat.</p>
</div>
<div class="paragraph">
<p>What’s <strong>minishift</strong>? <strong>minishift</strong> is the definitive tool for local OpenShift for development. If you want to know more, don’t forget to read the final blog in this series.</p>
</div>
</div>
</div></p>
               -->
           </article>
       </div>
    
       <div class="list__item">
           <article class="archive__item" itemscope itemtype="http://schema.org/CreativeWork">
               <h2 class="archive__item-title" itemprop="headline"><a href="/2017/04/developing-locally-openshift-origin-all-in-one/">Developing locally with OpenShift - Origin all in one. Where we started</a></h2>
               <p class="page__meta">
                  <i class="fa fa-clock-o" aria-hidden="true"></i> 4 minutes
                  Posted: 06/Apr/2017 by Jorge Morales
               </p>
               <p class="archive__item-excerpt" itemprop="description">In part 2 of this series of articles we will explore the first local development environment that existed for Openshift Origin and OpenShift 3.</p>
               <!--
               <p class="archive__item-excerpt" itemprop="description"><div class="paragraph">
<p>At the time OpenShift started, we realized that having a local development environment was important to make iterative development work more agile. Back then, the requirements that we had for a local development environment were pretty clear:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It needs to work on linux, mac and windows</p>
</li>
<li>
<p>It needs to be easy to run</p>
</li>
<li>
<p>It needs to be easily disposable</p>
</li>
<li>
<p>Resources used need to be adjustable</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There was an existing technology that was meeting all these requirements, Vagrant by Hashicorp. Vagrant is a tool that allows you to start a VM, from a template, and then provision/bootstrap the VM on first boot. Then you could start and stop that VM for as many times as you want/need before you discard it. This technology provided us a way to give a base VM image, based out of Centos or RHEL, that was on first boot bootstrapped to contain a full OpenShift environment.</p>
</div>
<div class="paragraph">
<p>The OpenShift evangelist team started this work and created what we called the “<strong>Origin all-in-one</strong>” which bootstrapped you an OpenShift Origin all-in-one node with additional content. This effort also started based on the necessity of the team to provide a way for developers to have a VM they could take home in order to learn OpenShift.</p>
</div>
<div class="paragraph">
<p>The effort lead to an official variant, called <strong>CDK (Container Development Kit)</strong> and supported by our Red Hat Developers Tools, that was based on Red Hat Enterprise Linux and installed the Enterprise version of OpenShift, now called OpenShift Container Platform. It provides mostly the same capabilities as the all-in-one, but the most important fact for this variant is that Red Hat supports it. You just need to subscribe the VM (free subscription for developers) and you’ll have access to our Enterprise product.</p>
</div>
<div class="paragraph">
<p>The downsides to using Vagrant is that you need to use a full Operating System VM that required an initial download of some GBs of data prior to being able to start working. Also it requires a considerable amount of resources not always easily available in the developer’s workstations or laptops.</p>
</div>
<div class="paragraph">
<p>Relying on Vagrant seemed the right approach at the time, and in the case of CDK, Red Hat invested in having a team of developers working upstream on some of the plugins used. The truth is that after some time, Vagrant seems more an abandoned project where every release breaks a feature and introduces incompatibilities with some of the versions of the hypervisors, e.g. VirtualBox which makes it complicated for the users to have it properly installed and functional.</p>
</div>
<div class="paragraph">
<p>I’m not going to explain how this approach works. If you’re interested you can just look at <a href="https://github.com/openshift-evangelists/vagrant-origin/">our docs</a>.</p>
</div>
<div class="paragraph">
<p>Even though we could admit that the Origin all-in-one VM has been very successful, it has become less and less the defacto way of running a local OpenShift instance, and it will no longer be maintained, as we have <a href="https://blog.openshift.com/goodbye-openshift-all-in-one-vm-hello-minishift/">announced</a>. But don’t be afraid, that doesn’t mean there will be no solution. In the following posts I’ll be talking about more options, so stay tuned!</p>
</div></p>
               -->
           </article>
       </div>
    
</div>

    </div>

    <div class="page__footer">
        <footer>
            <!-- start custom footer snippets -->
            <!-- end custom footer snippets -->
            <div class="page__footer-follow">
                <ul class="social-icons">
                    <li><strong>Follow:</strong></li>
                    <li><a href="https://twitter.com/UnPOUcoDe"><i class="fa fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
                    <li><a href="/atom.xml"><i class="fa fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
                </ul>
            </div>
            <div class="page__footer-copyright">&copy; 2016 Jorge Morales Pou.</div>
        </footer>
    </div>
    <script src="/js/main.min.js"></script>
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-81343831-1']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script');
            ga.type = 'text/javascript';
            ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(ga, s);
        })();
    </script>
</body>

</html>
